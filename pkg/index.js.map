{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["type Options = {\n  waveformWidth: number;\n  waveformHeight: number;\n  waveformColor: string;\n  barAlign: string;\n  barWidth: number;\n  barGap: number;\n  drawMode: \"png\" | \"svg\";\n}\n\nconst defaultOptions: Options = {\n  waveformWidth: 500,\n  waveformHeight: 80,\n  waveformColor: \"#000\",\n  barAlign: \"center\",\n  barWidth: 1,\n  barGap: 0,\n  drawMode: \"png\",\n};\n\nasync function decodeAudioData(fileArrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\n  return new Promise((resolve, reject) => {\n    const audioContext = new AudioContext();\n\n    audioContext.decodeAudioData(fileArrayBuffer, (audioBuffer) => {\n      if (!audioBuffer) {\n        reject(new Error(\"Could not decode audio data\"));\n      } else {\n        resolve(audioBuffer);\n      }\n    });\n  });\n}\n\nfunction generateNewSVGTarget(width, height): SVGSVGElement {\n  const svg = document.createElement(\"svg\");\n\n  svg.id = crypto.randomUUID();\n\n  svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n  svg.setAttribute(\"version\", \"1.1\");\n  svg.setAttributeNS(null, \"viewBox\", `0 0 ${width} ${height}`);\n\n  return svg as unknown as SVGSVGElement;\n}\n\nfunction generateNewCanvasTarget(width, height) {\n  const canvas = document.createElement(\"canvas\");\n\n  canvas.id = crypto.randomUUID();\n  canvas.width = width;\n  canvas.height = height;\n\n  return canvas;\n}\n\nclass WaveformGenerator {\n  #fileArrayBuffer: ArrayBuffer;\n  #audioBuffer: AudioBuffer;\n  #svg: SVGSVGElement;\n  #canvas: HTMLCanvasElement;\n  #canvasContext: CanvasRenderingContext2D;\n  #options: Options = defaultOptions;\n\n\n  constructor(fileArrayBuffer: ArrayBuffer) {\n    this.#fileArrayBuffer = fileArrayBuffer;\n  }\n\n  /**\n   * Generate the waveform.\n   */\n  async getWaveform(options: Options = defaultOptions): Promise<string> {\n    this.#options = Object.assign({}, defaultOptions, options);\n\n    const { waveformWidth, waveformHeight, drawMode } = this.#options;\n\n    if (!this.#audioBuffer) {\n      this.#audioBuffer = await decodeAudioData(this.#fileArrayBuffer.slice(0));\n    }\n\n    if (drawMode === \"png\") {\n      this.#canvas = generateNewCanvasTarget(waveformWidth, waveformHeight);\n      this.#canvasContext = this.#canvas.getContext(\"2d\");\n    } else if (drawMode === \"svg\") {\n      this.#svg = generateNewSVGTarget(waveformWidth, waveformHeight);\n      this.#svg.appendChild(this.generateSVGStylesheet());\n    }\n\n    this.drawWaveform(this.#audioBuffer);\n\n    if (drawMode === \"png\") {\n      return this.#canvas.toDataURL();\n    }\n\n    return `data:image/svg+xml;base64,${btoa(\n          `<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">${this.#svg.outerHTML}`,\n        )}`;\n  }\n\n  generateSVGStylesheet(): HTMLStyleElement {\n    const { waveformColor, barWidth, barGap } = this.#options;\n    const svgStylesheet = document.createElement(\"style\");\n\n    svgStylesheet.setAttribute(\"type\", \"text/css\");\n    const strokeWidth = (barGap !== 0)\n      ? (barWidth * Math.abs(1 - barGap))\n      : barWidth;\n    svgStylesheet.appendChild(\n      document.createTextNode(\n        `path{stroke:${waveformColor};stroke-width:${strokeWidth}}`,\n      ),\n    );\n\n    return svgStylesheet;\n  }\n\n  drawBarToCanvas(x: number, y: number, barHeight: number): void {\n    const { waveformColor, barWidth } = this.#options;\n\n    const finalX = Math.floor(x - 1);\n    const finalY = Math.floor(y - 1);\n\n    this.#canvasContext.fillStyle = waveformColor;\n    this.#canvasContext.fillRect(finalX, finalY, barWidth, barHeight);\n  }\n\n  drawBarToSVG(x: number, y: number, barHeight: number): void {\n    const path = document.createElement(\"path\");\n\n    path.setAttribute(\n      \"d\",\n      `M${x} ${y} L${x} ${y} L${x} ${y + barHeight} L${x} ${y + barHeight} L${x} ${y} Z`,\n    );\n\n    this.#svg.appendChild(path);\n  }\n\n  drawBar({ position, height }: {\n      position: number;\n      height: number;\n    }): void {\n    const { barGap, barAlign, waveformHeight, drawMode } = this.#options;\n    let { barWidth } = this.#options;\n\n    if (barGap !== 0) {\n      barWidth *= Math.abs(1 - barGap);\n    }\n\n    const x = position + (barWidth / 2);\n    let y: number;\n\n    switch (barAlign) {\n      case \"top\":\n        y = 0;\n        break;\n      case \"bottom\":\n        y = waveformHeight - height;\n        break;\n      case \"center\":\n      default:\n        y = (waveformHeight / 2) - (height / 2);\n        break;\n    }\n\n    if (drawMode === \"png\") {\n      this.drawBarToCanvas(x, y, height);\n    } else if (drawMode === \"svg\") {\n      this.drawBarToSVG(x, y, height);\n    } else {\n      throw new Error(\n        `Unsupported drawMode in options; ${drawMode}. Allowed: png, svg`,\n      );\n    }\n  }\n\n  bufferMeasure(position: number, length: number, data: Float32Array<ArrayBufferLike>): number {\n    let sum = 0.0;\n\n    for (\n      let i = position, ref = (position + length) - 1;\n      position <= ref ? i <= ref : i >= ref;\n      position <= ref ? i++ : i--\n    ) {\n      sum += data[i] ** 2;\n    }\n\n    return Math.sqrt(sum / data.length);\n  }\n\n  drawWaveform(audioBuffer: AudioBuffer): void {\n    const buffer = audioBuffer.getChannelData(0);\n\n    const { waveformWidth, waveformHeight, barWidth } = this.#options;\n\n    const len = Math.floor(buffer.length / waveformWidth);\n\n    const bars = [];\n    const values = [];\n\n    for (let i = 0; i < waveformWidth; i += barWidth) {\n      const bar: { position: number, height: number } = {\n        position: i,\n        height: this.bufferMeasure(i * len, len, buffer)\n      };\n\n      values.push(bar.height);\n      bars.push(bar);\n    }\n\n    const scale = waveformHeight / Math.max.apply(null, values);\n\n    for (const { position, height } of bars) {\n      this.drawBar({ position, height: height * scale });\n    }\n  }\n}\n\nexport default WaveformGenerator;\n"],
  "mappings": "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",
  "names": ["defaultOptions", "decodeAudioData", "fileArrayBuffer", "resolve", "reject", "audioBuffer", "generateNewSVGTarget", "width", "height", "svg", "generateNewCanvasTarget", "canvas", "_fileArrayBuffer", "_audioBuffer", "_svg", "_canvas", "_canvasContext", "_options", "WaveformGenerator", "__privateAdd", "__privateSet", "options", "waveformWidth", "waveformHeight", "drawMode", "__privateGet", "waveformColor", "barWidth", "barGap", "svgStylesheet", "strokeWidth", "x", "y", "barHeight", "finalX", "finalY", "path", "position", "barAlign", "length", "data", "sum", "i", "ref", "buffer", "len", "bars", "values", "bar", "scale", "index_default"]
}
